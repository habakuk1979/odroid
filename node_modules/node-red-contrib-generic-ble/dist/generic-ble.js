"use strict";var _noble=_interopRequireDefault(require("./noble")),_debug=_interopRequireDefault(require("debug"));function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}
/**
 * @license
 * Copyright (c) 2017 CANDY LINE INC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const debug=(0,_debug.default)("node-red-contrib-generic-ble:index"),debugIn=(0,_debug.default)("node-red-contrib-generic-ble:index:generic-ble-in"),debugOut=(0,_debug.default)("node-red-contrib-generic-ble:index:generic-ble-out"),debugCfg=(0,_debug.default)("node-red-contrib-generic-ble:index:generic-ble"),debugApi=(0,_debug.default)("node-red-contrib-generic-ble:index:api");"test"!==process.env.NODE_ENV&&(debug('Requiring "source-map-support/register"...'),require("source-map-support/register"));const configBleDevices={},genericBleState={scanning:!1},handlers={};function getAddressOrUUID(e){return e?e.address&&"unknown"!==e.address?e.address:e.uuid:null}function stopBLEScanning(e){genericBleState.scanning&&(e.log.info("[GenericBLE] Stop BLE scanning"),_noble.default.stopScanning(),genericBleState.scanning=!1)}function startBLEScanning(e){genericBleState.scanning||(handlers.onDiscover||(handlers.onDiscover=function(e){return t=>{const i=getAddressOrUUID(t);i&&t.connectable&&(debug(`[GenericBLE:DISCOVER] <${i}> ${t.advertisement.localName}`),e.nodes.eachNode(i=>{"Generic BLE"===i.type&&t.uuid===i.uuid&&e.nodes.getNode(i.id).discovered()}))}}(e)),handlers.onMiss||(handlers.onMiss=function(e){return t=>{const i=getAddressOrUUID(t);debug(`[GenericBLE:MISS] <${i}> ${t.advertisement.localName}`),e.nodes.eachNode(i=>{"Generic BLE"===i.type&&i.uuid===t.uuid&&e.nodes.getNode(i.id).missed()})}}(e)),handlers.onStateChange||(handlers.onStateChange=function(e){return t=>{"poweredOn"===t?genericBleState.scanning||(e.log.info("[GenericBLE] Start BLE scanning"),_noble.default.startScanning([],!0),genericBleState.scanning=!0):genericBleState.scanning&&(e.log.info("[GenericBLE] Stop BLE scanning"),_noble.default.stopScanning(),genericBleState.scanning=!1)}}(e)),handlers.onError||(handlers.onError=function(e){return t=>{const i=`[GenericBLE:ERROR] ${t.message}, ${t.stack}`;debug(i),e.log.error(i),_noble.default.initialized||e.log.error("The error seems to be a BlueZ Permission Error. See 'Installation Note' in README at https://flows.nodered.org/node/node-red-contrib-generic-ble for addressing the issue."),Object.values(configBleDevices).forEach(e=>e.emit("error"))}}(e)),_noble.default.removeListener("discover",handlers.onDiscover),_noble.default.removeListener("miss",handlers.onMiss),_noble.default.removeListener("stateChange",handlers.onStateChange),_noble.default.removeListener("error",handlers.onError),_noble.default.addListener("discover",handlers.onDiscover),_noble.default.addListener("miss",handlers.onMiss),_noble.default.addListener("stateChange",handlers.onStateChange),_noble.default.addListener("error",handlers.onError),"poweredOn"===_noble.default.state?(e.log.info("[GenericBLE] Start BLE scanning"),_noble.default.startScanning([],!0),genericBleState.scanning=!0):debug("noble.state=>"+_noble.default.state))}async function toApiObject(e){return e?{localName:e.advertisement.localName,address:"unknown"===e.address?"":e.address,uuid:e.uuid,rssi:e.rssi}:null}module.exports=function(e){function t(t){const i={uuid:t.uuid,name:t.name||e._("generic-ble.label.unnamedChr"),type:t.type||e._("generic-ble.label.customType"),notifiable:t.properties.indexOf("notify")>=0,readable:t.properties.indexOf("read")>=0,writable:t.properties.indexOf("write")>=0,writeWithoutResponse:t.properties.indexOf("writeWithoutResponse")>=0,object:t,addDataListener:e=>!i.dataListener&&(i.dataListener=e,i.object.removeAllListeners("data"),i.object.on("data",e),!0),unsubscribe:()=>new Promise(e=>{const t=_noble.default._peripherals[i._peripheralId];if(!i.notifiable||!t||"connected"!==t.state)return e();delete i.dataListener,i.object.unsubscribe(e)})};return i}e.nodes.registerType("Generic BLE",class{constructor(t){e.nodes.createNode(this,t),this.localName=t.localName,this.address=t.address,this.uuid=t.uuid,this.characteristics=[];const i=getAddressOrUUID(t);i&&(configBleDevices[i]=this),this.nodes={},["connected","disconnected","error","connecting","disconnecting","missing"].forEach(e=>{this.on(e,()=>{try{Object.keys(this.nodes).forEach(t=>{this.nodes[t].emit(e)})}catch(e){this.error(e)}})}),this.on("close",e=>{genericBleState.scanning&&stopBLEScanning(),Object.keys(configBleDevices).forEach(e=>delete configBleDevices[e]),this.removeAllListeners("ble-notify"),this.shutdown().then(e).catch(e)}),process.nextTick(()=>{_noble.default.initialized&&this.emit("missing")})}async discovered(){debugCfg(`<discovered:${this.uuid}> noble._peripherals=>${Object.keys(_noble.default._peripherals)}`);const e=_noble.default._peripherals[this.uuid];e&&this.emit(e.state||"disconnected")}async missed(){debugCfg(`<missed:${this.uuid}>`),this.emit("missing")}async connectPeripheral(){debugCfg(`<connectPeripheral:${this.uuid}> noble._peripherals=>${Object.keys(_noble.default._peripherals)}`);const e=_noble.default._peripherals[this.uuid];if(e){switch(debug(`<connectPeripheral${this.uuid}> peripheral.state=>${e.state}`),e.state){case"disconnected":this.emit("disconnected"),e._disconnectedHandlerSet||(e._disconnectedHandlerSet=!0,e.once("disconnect",()=>{this.emit("disconnected"),e._disconnectedHandlerSet=!1})),e._connectHandlerSet||(e._connectHandlerSet=!0,e.once("connect",i=>{if(i)return this.log("<connectPeripheral:connect> error:"+i.message),void this.emit("disconnected");this.emit("connected"),e._connectHandlerSet=!1,e.discoverAllServicesAndCharacteristics((e,i)=>{debug(`<connectPeripheral${this.uuid}:discoverAllServicesAndCharacteristics> Callback OK!`),e?this.log(`<connectPeripheral${this.uuid}:discoverAllServicesAndCharacteristics> error:${e.message}`):this.characteristics=i.reduce((e,t)=>e.concat(t.characteristics),[]).map(e=>t(e))})}),e.connect(),this.emit("connecting"));break;case"connected":e.services&&(this.characteristics=e.services.reduce((e,t)=>e.concat(t.characteristics),[]).map(e=>t(e))),e._disconnectedHandlerSet||(e._disconnectedHandlerSet=!0,e.once("disconnect",()=>{this.emit("disconnected"),e._disconnectedHandlerSet=!1})),this.emit("connected");break;case"disconnecting":case"connecting":this.emit(e.state)}return e.state}this.emit("missing")}async disconnectPeripheral(){debugCfg(`<disconnectPeripheral:${this.uuid}> noble._peripherals=>${Object.keys(_noble.default._peripherals)}`);const e=_noble.default._peripherals[this.uuid];return e?"disconnected"===e.state?(debugCfg(`<disconnectPeripheral:${this.uuid}> peripheral is already disconnected.`),void this.emit("disconnected")):(e._disconnectedHandlerSet||(e._disconnectedHandlerSet=!0,e.once("disconnect",()=>{this.emit("disconnected"),e._disconnectedHandlerSet=!1})),e.disconnect(),void this.emit("disconnecting")):(debugCfg(`<disconnectPeripheral:${this.uuid}> peripheral is already gone.`),void this.emit("missing"))}async shutdown(){await Promise.all(this.characteristics.map(e=>e.unsubscribe()))}register(e){this.nodes[e.id]=e}remove(e){delete this.nodes[e.id]}async write(e){if(!e)throw Error("Nothing to write");const t=await this.connectPeripheral();if("connected"!==t)throw debugCfg(`[write] Peripheral:${this.uuid} is NOT ready. state=>${t}`),Error("Not yet connected.");let i=this.characteristics.filter(e=>e.writable||e.writeWithoutResponse);if(debugCfg("characteristics => "+JSON.stringify(this.characteristics.map(e=>({uuid:e.uuid,notifiable:e.notifiable,readable:e.readable,writable:e.writable,writeWithoutResponse:e.writeWithoutResponse})))),debugCfg("writables.length => "+i.length),0===i.length)return;const n=Object.keys(e);i=i.filter(e=>n.indexOf(e.uuid)>=0),debugCfg("UUIDs to write => "+n),debugCfg("writables.length => "+i.length),0!==i.length&&await Promise.all(i.map(t=>new Promise((i,n)=>{const s=function(e,t=1){if(Buffer.isBuffer(e))return e;if("number"==typeof e){let i=parseInt(e).toString(16);return i.length<2*t&&(i=Array(2*t-i.length+1).join("0")+i),i.length%2==1&&(i="0"+i),Buffer.from(i,"hex")}if("string"==typeof e)return e.length<2*t&&(e=Array(2*t-e.length+1).join("0")+e),e.length%2==1&&(e="0"+e),Buffer.from(e,"hex");if(Array.isArray(e)){for(let i=0;i<t-e.length;i++)e.splice(0,0,0);return Buffer.from(e)}return Buffer.alloc(0)}(e[t.uuid]);debugCfg(`<Write> uuid => ${t.uuid}, data => ${s.toString("hex")}, writeWithoutResponse => ${t.writeWithoutResponse}`),t.object.write(s,t.writeWithoutResponse,e=>{if(e)return debugCfg(`<Write> ${t.uuid} => FAIL`),n(e);debugCfg(`<Write> ${t.uuid} => OK`),i(!0)})})))}async read(e=""){const t=await this.connectPeripheral();if("connected"!==t)throw debugCfg(`[read] Peripheral:${this.uuid} is NOT ready. state=>${t}`),Error("Not yet connected.");e=e.split(",").map(e=>e.trim()).filter(e=>e);const i=this.characteristics.filter(t=>{if(t.readable)return 0===e.length||e.indexOf(t.uuid)>=0});if(debugCfg("characteristics => "+JSON.stringify(this.characteristics.map(e=>({uuid:e.uuid,notifiable:e.notifiable,readable:e.readable,writable:e.writable,writeWithoutResponse:e.writeWithoutResponse})))),debugCfg("readables.length => "+i.length),0===i.length)return null;const n=this.characteristics.filter(t=>{if(t.notifiable)return 0===e.length||e.indexOf(t.uuid)>=0}),s={};return await Promise.all(n.map(e=>e.unsubscribe())),await Promise.all(i.map(e=>new Promise((t,i)=>{e.object.read((n,r)=>{if(n)return debug(`<Read> ${e.uuid} => FAIL`),i(n);debugCfg(`<Read> ${e.uuid} => ${JSON.stringify(r)}`),s[e.uuid]=r,t()})}))),Object.keys(s).length>0?s:null}async subscribe(e="",t=0){const i=await this.connectPeripheral();if("connected"!==i)throw this.log(`[subscribe] Peripheral:${this.uuid} is NOT ready. state=>${i}`),Error("Not yet connected.");e=e.split(",").map(e=>e.trim()).filter(e=>e);const n=this.characteristics.filter(t=>{if(t.notifiable)return 0===e.length||e.indexOf(t.uuid)>=0});debugCfg("characteristics => "+JSON.stringify(this.characteristics.map(e=>({uuid:e.uuid,notifiable:e.notifiable,readable:e.readable,writable:e.writable,writeWithoutResponse:e.writeWithoutResponse})))),debugCfg("notifiables.length => "+n.length),0!==n.length&&await Promise.all(n.map(async e=>{e.addDataListener((t,i)=>{if(i){let i={notification:!0};i[e.uuid]=t,this.emit("ble-notify",this.uuid,i)}}),e.object.subscribe(e=>{e&&(this.emit("error",e),this.log("subscription error: "+e.message))}),t>0&&setTimeout(()=>{e.object.unsubscribe(e=>{if(e)this.emit("error",e),this.log("unsubscription error: "+e.message);else{const e=_noble.default._peripherals[this.uuid];e?this.emit(e.state):this.emit("missing")}})},5e3)}))}});e.nodes.registerType("Generic BLE in",class{constructor(t){e.nodes.createNode(this,t),this.useString=t.useString,this.notification=t.notification,this.genericBleNodeId=t.genericBle,this.genericBleNode=e.nodes.getNode(this.genericBleNodeId),this.genericBleNode&&(this.notification&&this.genericBleNode.on("ble-notify",this.onBleNotify.bind(this)),this.on("connected",()=>{this.status({fill:"green",shape:"dot",text:"generic-ble.status.connected"})}),["disconnected","error","missing"].forEach(e=>{this.on(e,()=>{this.status({fill:"red",shape:"ring",text:"generic-ble.status."+e})})}),["connecting","disconnecting"].forEach(e=>{this.on(e,()=>{this.status({fill:"grey",shape:"ring",text:"generic-ble.status."+e})})}),this.genericBleNode.register(this),this.on("input",async(t,i)=>{debugIn("input arrived! msg=>"+JSON.stringify(t));let n=t.payload||{};try{"string"==typeof n&&(n=JSON.parse(t.payload))}catch(e){}try{if("scanStart"===t.topic)return void startBLEScanning(e);if("scanStop"===t.topic)return void stopBLEScanning(e);if("scanRestart"===t.topic)return stopBLEScanning(e),void setTimeout(()=>{startBLEScanning(e)},1e3);if("connect"===t.topic)await this.genericBleNode.connectPeripheral();else if("disconnect"===t.topic)await this.genericBleNode.disconnectPeripheral();else if(n.notify)await this.genericBleNode.subscribe(t.topic,n.period),debugIn(`<${this.genericBleNode.uuid}> subscribe: OK`);else{const e=await this.genericBleNode.read(t.topic);if(debugIn(`<${this.genericBleNode.uuid}> read: OK`),!e)return void this.warn(`<${this.genericBleNode.uuid}> tpoic[${t.topic}]: (no data)`);let n={uuid:this.genericBleNode.uuid,characteristics:e};this.useString&&(n=JSON.stringify(n));const s=this;(i=i||function(){s.send.apply(s,arguments)})({payload:n})}}catch(e){debugIn(`<${this.genericBleNode.uuid}> tpoic[${t.topic}]: (err:${e}, stack:${e.stack})`),this.error(`<${this.genericBleNode.uuid}> tpoic[${t.topic}]: (err:${e}, stack:${e.stack})`)}}),this.on("close",()=>{this.genericBleNode&&this.genericBleNode.remove(this)})),this.name=t.name}onBleNotify(e,t,i){if(i)return void this.error(`<${e}> notify: (err:${i}, stack:${i.stack})`);let n={uuid:e,characteristics:t};if(this.useString)try{n=JSON.stringify(n)}catch(i){return void this.warn(`<${e}> notify: (err:${i}, stack:${i.stack})`)}this.send({payload:n})}});e.nodes.registerType("Generic BLE out",class{constructor(t){e.nodes.createNode(this,t),this.genericBleNodeId=t.genericBle,this.genericBleNode=e.nodes.getNode(this.genericBleNodeId),this.genericBleNode&&(this.on("connected",()=>{this.status({fill:"green",shape:"dot",text:"generic-ble.status.connected"})}),["disconnected","error","missing"].forEach(e=>{this.on(e,()=>{this.status({fill:"red",shape:"ring",text:"generic-ble.status."+e})})}),["connecting","disconnecting"].forEach(e=>{this.on(e,()=>{this.status({fill:"grey",shape:"ring",text:"generic-ble.status."+e})})}),this.genericBleNode.register(this),this.on("input",async e=>{debugOut("input arrived! msg=>"+JSON.stringify(e));try{"connect"===e.topic?await this.genericBleNode.connectPeripheral():"disconnect"===e.topic?await this.genericBleNode.disconnectPeripheral():(await this.genericBleNode.write(e.payload),debugOut(`<${this.genericBleNode.uuid}> write: OK`))}catch(e){debugOut(`<${this.genericBleNode.uuid}> write: (err:${e})`),this.error(e)}}),this.on("close",()=>{this.genericBleNode&&this.genericBleNode.remove(this)})),this.name=t.name}}),e.events.on("runtime-event",t=>{debugApi("[GenericBLE] <runtime-event> "+JSON.stringify(t)),"runtime-state"===t.id&&Object.keys(configBleDevices).length>0&&(stopBLEScanning(e),startBLEScanning(e))}),e.httpAdmin.get("/__blestate",e.auth.needsPermission("generic-ble.read"),async(e,t)=>(debugApi(`${e.method}:${e.originalUrl}`),t.status(200).send(genericBleState).end())),e.httpAdmin.post("/__blescan/:sw",e.auth.needsPermission("generic-ble.write"),async(t,i)=>{debugApi(`${t.method}:${t.originalUrl}, genericBleState.scanning:${genericBleState.scanning}`);const{sw:n}=t.params;return"start"===n?(startBLEScanning(e),i.status(200).send({status:200,message:"startScanning"}).end()):(stopBLEScanning(e),i.status(200).send({status:200,message:"stopScanning"}).end())}),e.httpAdmin.get("/__bledevlist",e.auth.needsPermission("generic-ble.read"),async(t,i)=>{debugApi(`${t.method}:${t.originalUrl}`);try{const e=(await Promise.all(Object.keys(_noble.default._peripherals).map(e=>{const t=toApiObject(_noble.default._peripherals[e]);if(t)return t}))).filter(e=>e);debugApi("/__bledevlist",JSON.stringify(e,null,2)),i.json(e)}catch(t){if(e.log.error(`/__bledevlist err:${t}\n=>${t.stack||t.message}`),!i._headerSent)return i.status(500).send({status:500,message:t.message||t}).end()}}),e.httpAdmin.get("/__bledev/:uuid",e.auth.needsPermission("generic-ble.read"),async(t,i)=>{debugApi(`${t.method}:${t.originalUrl}`);const{uuid:n}=t.params;if(!n)return i.status(404).send({status:404,message:"missing peripheral"}).end();const s=_noble.default._peripherals[n];if(!s)return i.status(404).send({status:404,message:"missing peripheral"}).end();try{const t=await async function(e,t){const i=await toApiObject(e);switch(e.state){case"disconnected":await new Promise((n,s)=>{e.once("connect",r=>{if(r)return s(r);const a=()=>s(Error("Missing Peripheral Device"));e.once("disconnect",a),e.discoverAllServicesAndCharacteristics((r,c)=>{if(debug(`<toDetailedObject${e.uuid}:discoverAllServicesAndCharacteristics> Callback OK!`),e.removeListener("disconnect",a),r)return s(r);let o=!1;return i.characteristics=c.reduce((e,t)=>e.concat(t.characteristics),[]).map(s=>{const r={uuid:s.uuid,name:s.name||t._("generic-ble.label.unnamedChr"),type:s.type||t._("generic-ble.label.customType"),notifiable:s.properties.indexOf("notify")>=0,readable:s.properties.indexOf("read")>=0,writable:s.properties.indexOf("write")>=0,writeWithoutResponse:s.properties.indexOf("writeWithoutResponse")>=0};return"connected"===e.state&&"org.bluetooth.characteristic.gap.device_name"===s.type&&(o=!0,s.read((t,s)=>(t||(i.localName=s.toString(),e.advertisement.localName=i.localName),n()))),r}),o?void 0:n()})}),e.connect()});break;case"connected":{let n;i.characteristics=[],e.services.map(e=>{i.characteristics=i.characteristics.concat((e.characteristics||[]).map(e=>("org.bluetooth.characteristic.gap.device_name"===e.type&&(n=e),{uuid:e.uuid,name:e.name||t._("generic-ble.label.unnamedChr"),type:e.type||t._("generic-ble.label.customType"),notifiable:e.properties.indexOf("notify")>=0,readable:e.properties.indexOf("read")>=0,writable:e.properties.indexOf("write")>=0,writeWithoutResponse:e.properties.indexOf("writeWithoutResponse")>=0})))}),n&&!e.advertisement.localName&&"connected"===e.state&&await new Promise(t=>{n.read((n,s)=>(n||(i.localName=s.toString(),e.advertisement.localName=i.localName),t()))});break}case"disconnecting":case"connecting":default:return}return i}(s,e);return debugApi(`/__bledev/${n} OUTPUT`,JSON.stringify(t,null,2)),i.json(t)}catch(t){if(e.log.error(`/__bledev/${n} err:${t}\n=>${t.stack||t.message}`),!i._headerSent)return i.status(500).send({status:500,message:t.message||t}).end()}})};
//# sourceMappingURL=generic-ble.js.map
