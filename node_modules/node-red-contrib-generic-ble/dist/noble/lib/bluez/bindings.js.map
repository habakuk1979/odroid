{"version":3,"sources":["noble/lib/bluez/bindings.js"],"names":["_events","_interopRequireDefault","require","_debug","_dbusNext","uuid","default","process","env","NODE_ENV","debug","bluezObjectManager","_toUuid","objectPath","constructor","super","this","characteristicObjectPath","props","_getPropertiesInterface","_scanning","hciObjectPath","HCIDEVICE","objectStore","onDevicesServicesCharacteristicsDiscovered","_addDashes","onScanStarted","deviceObjectPathPrefix","_to128bitUuid","length","substring","toLowerCase","_stripDashes","split","join","_to16bitUuid","indexOf","[object Object]","hciProps","Get","value","Set","dbus","Variant","hciAdapter","SetDiscoveryFilter","DuplicateData","_scanFilterDuplicates","StartDiscovery","err","message","toString","emit","serviceUuids","allowDuplicates","_initialized","_startDiscovery","once","startScanning","StopDiscovery","onSigIntBinded","onSigInt","bind","on","onExit","bluezService","bus","getProxyObject","getInterface","bluezObjects","GetManagedObjects","Object","keys","Error","hciObject","onDevicesServicesCharacteristicsMissed","onAdapterPropertiesChanged","type","_option","proxy","prop","defaultValue","replace","_toObjectPath","peripheralUuid","toUpperCase","_getProxyObject","deviceUuid","deviceInterface","_getDeviceInterface","Connect","RemoveDevice","Disconnect","uuids","servicesResolved","onServicesResolved","serviceUuid","characteristicUuids","dashedCharacteristicUuids","map","objectPathPrefix","serviceObjectPaths","filter","serviceObjectPath","serviceObject","UUID","characteristicPathPrefix","discoveredCharacteristics","forEach","chr","includes","_listCharacteristics","resultChrs","values","properties","Flags","JSON","stringify","characteristicUuid","dashedCharacteristicUuid","data","chracteristic","_getCharacteristicInterface","Buffer","from","ReadValue","withoutResponse","toJSON","WriteValue","subscribe","notificationHandeler","async","interfaceName","changedProps","invalidatedProps","Value","notifying","StartNotify","StopNotify","interfacesAndProps","interfaces","device","onDeviceDiscovered","Alias","Connected","ServicesResolved","RSSI","rssi","address","Address","addressType","AddressType","connectable","Blocked","manufacturerData","ManufacturerData","unshift","serviceData","ServiceData","advertisement","localName","txPowerLevel","onDeviceMissed","Discovering","onScanStopepd","Powered","setTimeout","count","sigIntListeners","listeners","exit","stopScanning","bluez","BluezBindings"],"mappings":"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","file":"bindings.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2020 CANDY LINE INC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport EventEmitter from 'events';\nimport debugLogger from 'debug';\nimport dbus from 'dbus-next';\n\nconst debug = debugLogger('node-red-contrib-generic-ble:noble:bluez');\n\n// Workaround for a Jest Issue\n// https://github.com/kulshekhar/ts-jest/issues/727#issuecomment-422747294\nif (process.env.NODE_ENV !== 'test') {\n  debug('Requiring \"source-map-support/register\"...');\n  require('source-map-support/register');\n}\n\nclass BluezBindings extends EventEmitter {\n  constructor() {\n    super();\n\n    this.bus = dbus.systemBus();\n\n    this._scanFilterDuplicates = null;\n    this._scanning = false;\n    this.hciObjectPath = `/org/bluez/${process.env.HCIDEVICE || 'hci0'}`;\n\n    // Remove entry on onDevicesServicesCharacteristicsMissed()\n    this.objectStore = {\n      // key: objectPath, value: any\n    };\n\n    debug('BluezBindings instance created!');\n  }\n\n  _addDashes(uuid) {\n    if (!uuid || typeof uuid !== 'string') {\n      return uuid;\n    }\n    uuid = this._to128bitUuid(uuid);\n    if (uuid.length === 32) {\n      uuid = `${uuid.substring(0, 8)}-${uuid.substring(8, 12)}-${uuid.substring(\n        12,\n        16\n      )}-${uuid.substring(16, 20)}-${uuid.substring(20)}`;\n    }\n    return uuid.toLowerCase();\n  }\n\n  _stripDashes(uuid) {\n    if (typeof uuid === 'string') {\n      uuid = uuid.split('-').join('').toLowerCase();\n    }\n    return this._to16bitUuid(uuid);\n  }\n\n  _to128bitUuid(uuid) {\n    // Bluetooth Base UUID(00000000-0000-1000-8000-00805F9B34FB)\n    // Device Name (w/o dashes) : 2a00 => 00002a0000001000800000805f9b34fb\n    if (uuid.length === 4) {\n      uuid = `0000${uuid}-0000-1000-8000-00805f9b34fb`;\n    }\n    return uuid;\n  }\n\n  _to16bitUuid(uuid) {\n    // Bluetooth Base UUID(00000000-0000-1000-8000-00805F9B34FB)\n    // Device Name (w/o dashes) : 00002a0000001000800000805f9b34fb => 2a00\n    if (\n      uuid.indexOf('0000') === 0 &&\n      uuid.indexOf('00001000800000805f9b34fb') === 8\n    ) {\n      return uuid.substring(4, 8);\n    }\n    return uuid;\n  }\n\n  async _startDiscovery() {\n    try {\n      const powered = (await this.hciProps.Get('org.bluez.Adapter1', 'Powered'))\n        .value;\n      if (!powered) {\n        debug(`[_startDiscovery] Turning the adapter on...`);\n        await this.hciProps.Set(\n          'org.bluez.Adapter1',\n          'Powered',\n          new dbus.Variant('b', true)\n        );\n      }\n      debug(`[_startDiscovery] Setting discovery filter...`);\n      await this.hciAdapter.SetDiscoveryFilter({\n        DuplicateData: new dbus.Variant('b', !this._scanFilterDuplicates),\n      });\n      debug(`[_startDiscovery] Start Scanning...`);\n      await this.hciAdapter.StartDiscovery();\n    } catch (err) {\n      debug(\n        `[ERROR] _startDiscovery => err.message:${\n          err.message\n        }, err.toString:${err.toString()}`\n      );\n      if (!this._scanning) {\n        // failed to power on\n        this.emit('stateChange', 'poweredOff');\n      }\n    }\n  }\n\n  async startScanning(/* never used */ serviceUuids, allowDuplicates) {\n    if (this._initialized) {\n      this._scanFilterDuplicates = !allowDuplicates;\n      if (this._scanning) {\n        debug(`[startScanning] Scan already ongoing...`);\n      } else {\n        await this._startDiscovery();\n      }\n    } else {\n      this.once('poweredOn', () => {\n        debug(\n          `[startScanning] Trigger startScanning again as initialization done.`\n        );\n        this.startScanning(serviceUuids, allowDuplicates);\n      });\n    }\n  }\n\n  async stopScanning() {\n    if (this._initialized) {\n      debug(`[startScanning] Stop Scanning...`);\n      try {\n        await this.hciAdapter.StopDiscovery();\n      } catch (err) {\n        debug(\n          `[ERROR] stopScanning => err.message:${\n            err.message\n          }, err.toString:${err.toString()}`\n        );\n      }\n    }\n  }\n\n  async init() {\n    if (this._initialized) {\n      debug(`init: => already initialzied. Skip!`);\n      return;\n    }\n    debug(`initializing....`);\n\n    this.onSigIntBinded = this.onSigInt.bind(this);\n    /* Add exit handlers after `init()` has completed. If no adaptor\n    is present it can throw an exception - in which case we don't\n    want to try and clear up afterwards (issue #502) */\n    process.on('SIGINT', this.onSigIntBinded);\n    process.on('exit', this.onExit.bind(this));\n\n    try {\n      this.bluezService = await this.bus.getProxyObject('org.bluez', '/');\n      this.bluezObjectManager = this.bluezService.getInterface(\n        'org.freedesktop.DBus.ObjectManager'\n      );\n      const bluezObjects = await this.bluezObjectManager.GetManagedObjects();\n      debug(`Detected Object Paths:${Object.keys(bluezObjects)}`);\n      if (!bluezObjects[this.hciObjectPath]) {\n        debug(\n          `Missing Bluetooth Object, Path:${\n            this.hciObjectPath\n          }, Valid Paths:${Object.keys(bluezObjects)}}`\n        );\n        throw new Error(\n          `Missing Bluetooth Object, Path:${\n            this.hciObjectPath\n          }, Valid Paths:${Object.keys(bluezObjects)}}`\n        );\n      }\n      this.hciObject = await this.bus.getProxyObject(\n        'org.bluez',\n        this.hciObjectPath\n      );\n      this.hciProps = this.hciObject.getInterface(\n        'org.freedesktop.DBus.Properties'\n      );\n      this.hciAdapter = this.hciObject.getInterface('org.bluez.Adapter1');\n      this._scanning = (\n        await this.hciProps.Get('org.bluez.Adapter1', 'Discovering')\n      ).value;\n      if (this._scanning) {\n        this.onScanStarted();\n      }\n\n      // Devices/Services/Characteristics Discovered/Missed\n      this.bluezObjectManager.on(\n        'InterfacesAdded',\n        this.onDevicesServicesCharacteristicsDiscovered.bind(this)\n      );\n      this.bluezObjectManager.on(\n        'InterfacesRemoved',\n        this.onDevicesServicesCharacteristicsMissed.bind(this)\n      );\n\n      // Adapter Properties Change Listener\n      this.hciProps.on(\n        'PropertiesChanged',\n        this.onAdapterPropertiesChanged.bind(this)\n      );\n\n      // init finished\n      this._initialized = true;\n      debug(`async init() => done`);\n      this.emit('stateChange', 'poweredOn');\n    } catch (err) {\n      debug(\n        `async init() => error { message:${err.message}, type: ${err.type} }`\n      );\n      this.emit('stateChange', 'error');\n      this.emit('error', err);\n    }\n  }\n\n  _option(proxy, prop, defaultValue = null) {\n    if (proxy[prop]) {\n      return proxy[prop].value;\n    }\n    return defaultValue;\n  }\n\n  // /org/bluez/hci0/dev_11_22_33_DD_EE_FF => 112233ddeeff\n  _toUuid(objectPath) {\n    return objectPath\n      .split('/')[4]\n      .substring(4)\n      .replace(/_/g, '')\n      .toLowerCase();\n  }\n\n  _toObjectPath(peripheralUuid) {\n    // 112233ddeeff => /org/bluez/hci0/dev_11_22_33_DD_EE_FF\n    const uuid = peripheralUuid.toUpperCase();\n    return `/org/bluez/hci0/dev_${uuid[0]}${uuid[1]}_${uuid[2]}${uuid[3]}_${uuid[4]}${uuid[5]}_${uuid[6]}${uuid[7]}_${uuid[8]}${uuid[9]}_${uuid[10]}${uuid[11]}`;\n  }\n\n  async _getProxyObject(objectPath) {\n    return this.bus.getProxyObject('org.bluez', objectPath);\n  }\n\n  async _getDeviceInterface(objectPath) {\n    return (await this._getProxyObject(objectPath)).getInterface(\n      'org.bluez.Device1'\n    );\n  }\n\n  async _getPropertiesInterface(objectPath) {\n    return (await this._getProxyObject(objectPath)).getInterface(\n      'org.freedesktop.DBus.Properties'\n    );\n  }\n\n  async _getCharacteristicInterface(objectPath) {\n    return (await this._getProxyObject(objectPath)).getInterface(\n      'org.bluez.GattCharacteristic1'\n    );\n  }\n\n  async connect(deviceUuid) {\n    debug(`connect:deviceUuid=>${deviceUuid}`);\n    const objectPath = this._toObjectPath(deviceUuid);\n    const deviceInterface = await this._getDeviceInterface(objectPath);\n    try {\n      await deviceInterface.Connect();\n    } catch (err) {\n      debug(\n        `[ERROR] connect:deviceUuid=>${deviceUuid} => err.message:${\n          err.message\n        }, err.toString:${err.toString()}`\n      );\n      this.emit('connect', deviceUuid, err);\n      try {\n        await this.hciAdapter.RemoveDevice(objectPath);\n      } catch (err) {\n        debug(\n          `[${deviceUuid}]<connect> Error while removing the device: ${err.message}, ${err.type}`\n        );\n      }\n    }\n  }\n\n  async disconnect(deviceUuid) {\n    debug(`disconnect:deviceUuid=>${deviceUuid}`);\n    const objectPath = this._toObjectPath(deviceUuid);\n    const deviceInterface = await this._getDeviceInterface(objectPath);\n    try {\n      await deviceInterface.Disconnect();\n    } catch (err) {\n      debug(\n        `[ERROR] disconnect:deviceUuid=>${deviceUuid} => err.message:${\n          err.message\n        }, err.toString:${err.toString()}`\n      );\n      this.emit('disconnect', deviceUuid); // swallow err\n    }\n  }\n\n  async discoverServices(deviceUuid, uuids) {\n    debug(`discoverServices:deviceUuid=>${deviceUuid},uuids=>${uuids}`);\n    const objectPath = this._toObjectPath(deviceUuid);\n    const props = await this._getPropertiesInterface(objectPath);\n    const servicesResolved = (\n      await props.Get('org.bluez.Device1', 'ServicesResolved')\n    ).value;\n    if (servicesResolved) {\n      debug(\n        `discoverServices:deviceUuid=>${deviceUuid}, servicesResolved=>${servicesResolved}`\n      );\n      this.onServicesResolved(deviceUuid, props);\n    }\n  }\n\n  async _listCharacteristics(deviceUuid, serviceUuid, characteristicUuids) {\n    debug(\n      `[${deviceUuid}] Collecting characteristsics for the service ${serviceUuid}`\n    );\n    const dashedCharacteristicUuids = (characteristicUuids || []).map(\n      this._addDashes.bind(this)\n    );\n    const objectPath = this._toObjectPath(deviceUuid);\n    const objectPathPrefix = `${objectPath}/service`;\n    const bluezObjects = await this.bluezObjectManager.GetManagedObjects();\n    const serviceObjectPaths = Object.keys(bluezObjects).filter(\n      (serviceObjectPath) => serviceObjectPath.indexOf(objectPathPrefix) === 0\n    );\n    if (serviceObjectPaths.length === 0) {\n      return null;\n    }\n    const serviceObjectPath = serviceObjectPaths.filter((serviceObjectPath) => {\n      const serviceObject = bluezObjects[serviceObjectPath];\n      return (\n        serviceObject['org.bluez.GattService1'] &&\n        serviceObject['org.bluez.GattService1'].UUID.value === serviceUuid\n      );\n    })[0];\n    if (!serviceObjectPath) {\n      return null;\n    }\n    const characteristicPathPrefix = `${serviceObjectPath}/char`;\n    const discoveredCharacteristics = {};\n    serviceObjectPaths\n      .filter(\n        (serviceObjectPath) =>\n          serviceObjectPath.indexOf(characteristicPathPrefix) === 0\n      )\n      .forEach((characteristicObjectPath) => {\n        const chr =\n          bluezObjects[characteristicObjectPath][\n            'org.bluez.GattCharacteristic1'\n          ];\n        if (!chr) {\n          // org.bluez.GattDescriptor1\n          return;\n        }\n        if (\n          dashedCharacteristicUuids.length > 0 &&\n          !dashedCharacteristicUuids.includes(chr.UUID.value)\n        ) {\n          return;\n        }\n        discoveredCharacteristics[characteristicObjectPath] = chr;\n      });\n    return discoveredCharacteristics;\n  }\n\n  async discoverCharacteristics(deviceUuid, serviceUuid, characteristicUuids) {\n    debug(\n      `discoverCharacteristics:deviceUuid=>${deviceUuid},serviceUuid=>${serviceUuid},characteristicUuids=>${characteristicUuids}`\n    );\n    const discoveredCharacteristics = await this._listCharacteristics(\n      deviceUuid,\n      serviceUuid,\n      characteristicUuids\n    );\n    const resultChrs = Object.values(discoveredCharacteristics || {}).map(\n      (chr) => {\n        return {\n          uuid: this._stripDashes(chr.UUID.value),\n          properties: chr.Flags.value,\n        };\n      }\n    );\n    debug(`resultChrs => ${JSON.stringify(resultChrs)}`);\n    try {\n      this.emit('characteristicsDiscover', deviceUuid, serviceUuid, resultChrs);\n      debug(\n        `[${deviceUuid}] OK. Found ${resultChrs.length} Characteristics. characteristicsDiscover event`\n      );\n    } catch (err) {\n      debug(\n        `Failed to emit 'characteristicsDiscover' event. message:${err.message}`\n      );\n    }\n  }\n\n  async read(deviceUuid, serviceUuid, characteristicUuid) {\n    const dashedCharacteristicUuid = this._addDashes(characteristicUuid);\n    debug(\n      `read:deviceUuid=>${deviceUuid},serviceUuid=>${serviceUuid},dashedCharacteristicUuid=>${dashedCharacteristicUuid}`\n    );\n    const discoveredCharacteristics = await this._listCharacteristics(\n      deviceUuid,\n      serviceUuid,\n      [dashedCharacteristicUuid]\n    );\n    let data = null; // Buffer object\n    const characteristicObjectPath = Object.keys(discoveredCharacteristics)[0];\n    if (characteristicObjectPath) {\n      const chracteristic = await this._getCharacteristicInterface(\n        characteristicObjectPath\n      );\n      data = Buffer.from(await chracteristic.ReadValue({}));\n    }\n    debug(\n      `read:characteristicObjectPath=>${characteristicObjectPath}, data=>${JSON.stringify(\n        data\n      )}`\n    );\n    this.emit('read', deviceUuid, serviceUuid, characteristicUuid, data, false);\n  }\n\n  async write(\n    deviceUuid,\n    serviceUuid,\n    characteristicUuid,\n    data, // Buffer object\n    withoutResponse\n  ) {\n    const dashedCharacteristicUuid = this._addDashes(characteristicUuid);\n    debug(\n      `write:deviceUuid=>${deviceUuid},serviceUuid=>${serviceUuid},dashedCharacteristicUuid=>${dashedCharacteristicUuid},data=>${data},withoutResponse=>${withoutResponse}`\n    );\n    const discoveredCharacteristics = await this._listCharacteristics(\n      deviceUuid,\n      serviceUuid,\n      [dashedCharacteristicUuid]\n    );\n    const characteristicObjectPath = Object.keys(discoveredCharacteristics)[0];\n    if (characteristicObjectPath) {\n      const chracteristic = await this._getCharacteristicInterface(\n        characteristicObjectPath\n      );\n      data = data.toJSON().data;\n      const type = withoutResponse ? 'command' : 'request';\n      await chracteristic.WriteValue(data, {\n        type: new dbus.Variant('s', type),\n      });\n    }\n    debug(\n      `write:characteristicObjectPath=>${characteristicObjectPath}, data=>${JSON.stringify(\n        data\n      )}, withoutResponse=>${withoutResponse}`\n    );\n    this.emit(\n      'write',\n      deviceUuid,\n      serviceUuid,\n      characteristicUuid,\n      data,\n      withoutResponse\n    );\n  }\n\n  async notify(deviceUuid, serviceUuid, characteristicUuid, subscribe) {\n    const dashedCharacteristicUuid = this._addDashes(characteristicUuid);\n    debug(\n      `notify:deviceUuid=>${deviceUuid},serviceUuid=>${serviceUuid},dashedCharacteristicUuid=>${dashedCharacteristicUuid},subscribe?=>${subscribe}`\n    );\n    const discoveredCharacteristics = await this._listCharacteristics(\n      deviceUuid,\n      serviceUuid,\n      [dashedCharacteristicUuid]\n    );\n    const characteristicObjectPath = Object.keys(discoveredCharacteristics)[0];\n    if (characteristicObjectPath) {\n      const chracteristic = await this._getCharacteristicInterface(\n        characteristicObjectPath\n      );\n\n      // GattCharacteristic1 Properties Change Listener\n      const props = await this._getPropertiesInterface(\n        characteristicObjectPath\n      );\n      if (!this.objectStore[characteristicObjectPath]) {\n        this.objectStore[characteristicObjectPath] = {};\n      }\n      const objectStore = this.objectStore[characteristicObjectPath] || {};\n      this.objectStore[characteristicObjectPath] = objectStore;\n      if (!objectStore.notificationHandeler) {\n        debug(`Setting objectStore.notificationHandeler`);\n        objectStore.notificationHandeler = async (\n          /*string*/ interfaceName,\n          /*obj*/ changedProps,\n          /*string[]*/ invalidatedProps\n        ) => {\n          debug(\n            `[${characteristicObjectPath}]<PropertiesChanged> interfaceName:${interfaceName}, changedProps:${Object.keys(\n              changedProps\n            )}, invalidatedProps:${JSON.stringify(invalidatedProps)}`\n          );\n          if (interfaceName === 'org.bluez.GattCharacteristic1') {\n            if (changedProps.Value) {\n              this.emit(\n                'read',\n                deviceUuid,\n                serviceUuid,\n                characteristicUuid,\n                Buffer.from(changedProps.Value.value),\n                objectStore.notifying\n              );\n            }\n            debug(\n              `[${characteristicObjectPath}]<PropertiesChanged> GattCharacteristic1 changedProps=>${JSON.stringify(\n                changedProps\n              )}`\n            );\n          }\n        };\n        props.on('PropertiesChanged', objectStore.notificationHandeler);\n      }\n      const notifying = (\n        await props.Get('org.bluez.GattCharacteristic1', 'Notifying')\n      ).value;\n      debug(\n        `${deviceUuid}, subscribing(${characteristicUuid})? => ${notifying}`\n      );\n      if (subscribe) {\n        await chracteristic.StartNotify();\n        objectStore.notifying = true;\n        debug(\n          `${deviceUuid}, START subscribing(${characteristicUuid}) Notify events`\n        );\n      } else {\n        await chracteristic.StopNotify();\n        objectStore.notifying = false;\n        debug(\n          `${deviceUuid}, STOP subscribing(${characteristicUuid}) Notify events`\n        );\n      }\n      this.emit(\n        'notify',\n        deviceUuid,\n        serviceUuid,\n        characteristicUuid,\n        subscribe\n      );\n    }\n    debug(\n      `notify:characteristicObjectPath=>${characteristicObjectPath}, subscribe?=>${subscribe}`\n    );\n    this.emit('notify', deviceUuid, serviceUuid, characteristicUuid, subscribe);\n  }\n\n  // Methods not implemented:\n  // updateRssi(deviceUuid)\n  // discoverIncludedServices(deviceUuid, serviceUuid, serviceUuids)\n  // broadcast(deviceUuid, serviceUuid, characteristicUuid, broadcast)\n  // discoverDescriptors(deviceUuid, serviceUuid, characteristicUuid)\n  // readValue(deviceUuid, serviceUuid, characteristicUuid, descriptorUuid)\n  // writeValue(deviceUuid, serviceUuid, characteristicUuid, descriptorUuid, data)\n  // readHandle(deviceUuid, handle)\n  // writeHandle(deviceUuid, handle, data, withoutResponse)\n\n  async onDevicesServicesCharacteristicsDiscovered(\n    objectPath,\n    /*Object<String,Object<String,Variant>>*/ interfacesAndProps\n  ) {\n    const interfaces = Object.keys(interfacesAndProps);\n    if (interfaces.includes('org.bluez.Device1')) {\n      const device = interfacesAndProps['org.bluez.Device1'];\n      this.onDeviceDiscovered(objectPath, device);\n    } else {\n      debug(\n        `<onDevicesServicesCharacteristicsDiscovered> objectPath:${objectPath}, interfaces:${JSON.stringify(\n          interfaces\n        )}`\n      );\n    }\n  }\n\n  async onDeviceDiscovered(objectPath, device) {\n    debug(\n      `<onDeviceDiscovered> objectPath:${objectPath}, alias:${\n        device.Alias.value || 'n/a'\n      }, device: ${JSON.stringify(device)}`\n    );\n    const peripheralUuid = this._toUuid(objectPath);\n\n    // Device Properties Change Listener\n    const props = await this._getPropertiesInterface(objectPath);\n    props.on('PropertiesChanged', async (\n      /*string*/ interfaceName,\n      /*obj*/ changedProps,\n      /*string[]*/ invalidatedProps\n    ) => {\n      debug(\n        `[${peripheralUuid}]<PropertiesChanged> interfaceName:${interfaceName}, changedProps:${Object.keys(\n          changedProps\n        )}, invalidatedProps:${JSON.stringify(invalidatedProps)}`\n      );\n      if (interfaceName === 'org.bluez.Device1') {\n        if (changedProps.Connected) {\n          if (changedProps.Connected.value) {\n            this.emit('connect', peripheralUuid);\n          } else {\n            this.emit('disconnect', peripheralUuid);\n          }\n        }\n        if (\n          changedProps.ServicesResolved &&\n          changedProps.ServicesResolved.value\n        ) {\n          this.onServicesResolved(peripheralUuid, props);\n        }\n        if (changedProps.RSSI) {\n          this.emit('rssiUpdate', peripheralUuid, changedProps.RSSI.value);\n        }\n        if (invalidatedProps.includes('RSSI')) {\n          debug(\n            `[${peripheralUuid}]<PropertiesChanged> RSSI is invalidated. Removing the device.`\n          );\n          try {\n            await this.hciAdapter.RemoveDevice(objectPath);\n          } catch (err) {\n            if (err.type !== 'org.bluez.Error.DoesNotExist') {\n              debug(\n                `[${peripheralUuid}]<PropertiesChanged> Error while removing the device: ${err.message}, ${err.type}`\n              );\n            }\n          }\n        }\n      }\n    });\n\n    const rssi = this._option(device, 'RSSI');\n    const address = (device.Address.value || '').toLowerCase();\n    const addressType = device.AddressType.value;\n    const connectable = !device.Blocked.value;\n    const manufacturerData = device.ManufacturerData\n      ? Object.values(device.ManufacturerData.value)[0].value\n      : null;\n    if (manufacturerData) {\n      // Prepend Manufacturer ID\n      manufacturerData.unshift(Object.keys(device.ManufacturerData.value)[0]);\n    }\n    const serviceData = device.ServiceData\n      ? Object.keys(device.ServiceData.value).map((uuid) => {\n          return {\n            uuid,\n            data: Buffer.from(device.ServiceData.value[uuid].value),\n          };\n        })\n      : null;\n    const advertisement = {\n      localName: this._option(device, 'Alias'),\n      txPowerLevel: this._option(device, 'TxPower'),\n      serviceUuids: this._option(device, 'UUIDs', []),\n      manufacturerData: manufacturerData ? Buffer.from(manufacturerData) : null,\n      serviceData,\n    };\n\n    this.emit(\n      'discover',\n      peripheralUuid,\n      address,\n      addressType,\n      connectable,\n      advertisement,\n      rssi\n    );\n  }\n\n  async onServicesResolved(\n    peripheralUuid,\n    /*_getPropertiesInterface()*/ props\n  ) {\n    const serviceUuids = (await props.Get('org.bluez.Device1', 'UUIDs')).value;\n    this.emit('servicesDiscover', peripheralUuid, serviceUuids);\n  }\n\n  async onDevicesServicesCharacteristicsMissed(\n    objectPath,\n    /*String[]*/ interfaces\n  ) {\n    debug(\n      `<InterfacesRemoved:DevicesMissed> objectPath:${objectPath}, interfaces:${JSON.stringify(\n        interfaces\n      )}`\n    );\n    delete this.objectStore[objectPath];\n    if (interfaces.includes('org.bluez.Device1')) {\n      const peripheralUuid = this._toUuid(objectPath);\n      this.onDeviceMissed(peripheralUuid);\n    }\n  }\n\n  async onDeviceMissed(peripheralUuid) {\n    debug(`<onDeviceMissed> peripheralUuid:${peripheralUuid}`);\n    this.emit('miss', peripheralUuid);\n  }\n\n  async onAdapterPropertiesChanged(\n    /*string*/ interfaceName,\n    /*obj*/ changedProps,\n    /*string[]*/ invalidatedProps\n  ) {\n    debug(\n      `<Adapter:PropertiesChanged> interfaceName:${interfaceName}, changedProps:${Object.keys(\n        changedProps\n      )}, invalidatedProps:${JSON.stringify(invalidatedProps)}`\n    );\n    if (interfaceName === 'org.bluez.Adapter1') {\n      if (changedProps.Discovering) {\n        debug(`Discovering=>${changedProps.Discovering.value}`);\n        if (changedProps.Discovering.value) {\n          this.onScanStarted();\n        } else {\n          this.onScanStopepd();\n        }\n      }\n      if (changedProps.Powered) {\n        debug(`Powered=>${changedProps.Powered.value}`);\n        if (!changedProps.Powered.value) {\n          this._scanning = false;\n          setTimeout(async () => {\n            try {\n              await this._startDiscovery();\n            } catch (err) {\n              debug(\n                `Error while turning on the adapter. err.message:${err.message}, type:${err.type}`\n              );\n            }\n          }, 5 * 1000);\n        }\n      }\n      // Skip to show other props\n    }\n  }\n\n  async onScanStarted() {\n    debug(`<onScanStarted> fired`);\n    this._scanning = true;\n    const bluezObjects = await this.bluezObjectManager.GetManagedObjects();\n    // Invoke DevicesDiscovered event listerner if devices already exists\n    const deviceObjectPathPrefix = `${this.hciObjectPath}/dev_`;\n    let count = 0;\n    Object.keys(bluezObjects)\n      .filter(\n        (objectPath) =>\n          objectPath.indexOf(deviceObjectPathPrefix) === 0 &&\n          /*Exclude Service/Characteristic Paths*/ objectPath.length ===\n            37 /*=> '/org/bluez/hci0/dev_11_22_33_44_55_66'.length*/\n      )\n      .forEach(\n        /*deviceUuid*/ (objectPath) => {\n          debug(`<onScanStarted> ${count++}:${objectPath} Device Found`);\n          const interfacesAndProps = bluezObjects[objectPath];\n          this.onDevicesServicesCharacteristicsDiscovered(\n            objectPath,\n            /*Object<String,Object<String,Variant>>*/ interfacesAndProps\n          );\n        }\n      );\n    this.emit('scanStart', this._scanFilterDuplicates);\n  }\n\n  onScanStopepd() {\n    debug(`[onScanStopepd] fired`);\n    this._scanning = false;\n    this.emit('scanStop');\n  }\n\n  onSigInt() {\n    const sigIntListeners = process.listeners('SIGINT');\n\n    if (sigIntListeners[sigIntListeners.length - 1] === this.onSigIntBinded) {\n      // we are the last listener, so exit\n      // this will trigger onExit, and clean up\n      process.exit(1);\n    }\n  }\n\n  onExit() {\n    this.stopScanning();\n  }\n\n  get bluez() {\n    return true;\n  }\n}\n\nexport default new BluezBindings();\n"]}